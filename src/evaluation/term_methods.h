#pragma once

#include "core/bit_board.h"
#include "evaluation/generated/tuned_terms.h"
#include "evaluation/position_tables.h"
#include "movegen/bishops.h"
#include "movegen/kings.h"
#include "movegen/knights.h"
#include "movegen/pawns.h"
#include "movegen/rooks.h"
#include "utils/bit_operations.h"

#include <array>

#ifdef TUNING

#include "tuner/term_tracer.h"

#define ADD_SCORE_INDEXED(weightName, index) \
    {                                        \
        score += s_terms.weightName[index];  \
        if constexpr (player == PlayerWhite) \
            s_trace.weightName[index]++;     \
        else                                 \
            s_trace.weightName[index]--;     \
    }

#define ADD_SCORE_MULTI_INDEXED(weightName, multi, index) \
    {                                                     \
        score += s_terms.weightName[index] * multi;       \
        if constexpr (player == PlayerWhite)              \
            s_trace.weightName[index] += multi;           \
        else                                              \
            s_trace.weightName[index] -= multi;           \
    }

#else

#define ADD_SCORE_INDEXED(weightName, index) \
    {                                        \
        score += s_terms.weightName[index];  \
    }

#define ADD_SCORE_MULTI_INDEXED(weightName, multi, index) \
    {                                                     \
        score += s_terms.weightName[index] * multi;       \
    }

#endif

/* helper for single index tables */
#define ADD_SCORE(weightName) ADD_SCORE_INDEXED(weightName, 0)
#define ADD_SCORE_MULTI(weightName, multi) ADD_SCORE_MULTI_INDEXED(weightName, multi, 0)

namespace evaluation {

constexpr std::array<uint64_t, magic_enum::enum_count<Player>()> s_outpostRankMaks {
    s_row4Mask | s_row5Mask | s_row6Mask,
    s_row3Mask | s_row4Mask | s_row5Mask,
};

/* A context to precompute heavy operations so we don't have to do that
 * multiple times for a single evaluation
 * NOTE: Only values that are being reused between terms should be added here */
struct TermContext {
    const std::array<uint64_t, magic_enum::enum_count<Player>()> pawnAttacks;
    const std::array<uint64_t, magic_enum::enum_count<Player>()> kingZone;

    std::array<uint8_t, magic_enum::enum_count<Player>()> attacksToKingZone;

    /* attacks generated by each piece will be populated here */
    using AttackArray = std::array<uint64_t, magic_enum::enum_count<ColorlessPiece>()>;
    std::array<AttackArray, magic_enum::enum_count<Player>()> pieceAttacks;

    /* all accumulated attacks -> threats from a given player */
    std::array<uint64_t, magic_enum::enum_count<Player>()> threats;

    /* squares of all passed pawns -> used to compute free and protected pawns */
    std::array<uint64_t, magic_enum::enum_count<Player>()> passedPawns;
};

template<Player player>
[[nodiscard]] constexpr inline ColorlessPiece pieceToColorlessPiece(Piece piece) noexcept
{
    if constexpr (player == PlayerWhite) {
        assert(piece < BlackPawn);
        return static_cast<ColorlessPiece>(piece);
    } else {
        assert(piece >= BlackPawn);
        return static_cast<ColorlessPiece>(piece - BlackPawn);
    }
}

constexpr uint8_t pawnShieldSize = s_terms.pawnShieldBonus.size();
constexpr uint8_t pawnStormSize = s_terms.pawnStormScore.size();
constexpr uint8_t kingZoneSize = s_terms.kingZone.size();

template<Player player>
static inline TermScore getTempoScore(const BitBoard& board)
{
    TermScore score(0, 0);

    /* apply score for the current player */
    if (board.player == player) {
        ADD_SCORE(tempoScore);
    }

    return score;
}

/* NOTE: this method should only score static king-pawn parameters (ie. only where king and pawn are involved - no threats etc) */
template<Player player>
static inline TermScore getStaticKingPawnScore(const BitBoard& board, TermContext& ctx)
{
    TermScore score(0, 0);

    constexpr Piece ourPawn = player == PlayerWhite ? WhitePawn : BlackPawn;
    constexpr Piece theirPawn = player == PlayerWhite ? BlackPawn : WhitePawn;
    constexpr Piece ourKing = player == PlayerWhite ? WhiteKing : BlackKing;
    constexpr Piece theirKing = player == PlayerWhite ? BlackKing : WhiteKing;
    constexpr Player opponent = nextPlayer(player);

    const uint64_t ourPawns = board.pieces[ourPawn];
    const uint64_t theirPawns = board.pieces[theirPawn];

    const auto ourKingPos = utils::lsbToPosition(board.pieces[ourKing]);
    const auto theirKingPos = utils::lsbToPosition(board.pieces[theirKing]);

    /* add psqt king score here as it's the only static king score */
    ADD_SCORE_INDEXED(psqtKings, utils::relativePosition<player>(ourKingPos));

    /* add score if our king attacks one or more of their pawns */
    if (ctx.kingZone[player] & theirPawns) {
        ADD_SCORE(kingAttackPawn);
    }

    utils::bitIterate(ourPawns, [&](BoardPosition pos) {
        const uint64_t square = utils::positionToSquare(pos);
        const auto row = utils::relativeRow<player>(pos);

        ADD_SCORE_INDEXED(pieceValues, Pawn);
        ADD_SCORE_INDEXED(psqtPawns, utils::relativePosition<player>(pos));

        const auto doubledPawns = std::popcount(ourPawns & s_fileMaskTable[pos]);
        if (doubledPawns > 1)
            ADD_SCORE(doublePawnPenalty);

        if ((ourPawns & s_isolationMaskTable[pos]) == 0)
            ADD_SCORE(isolatedPawnPenalty);

        if (s_passedPawnMaskTable[player][ourKingPos] & square) {
            const uint8_t shieldDistance = std::min(utils::verticalDistance(ourKingPos, pos), pawnShieldSize);
            ADD_SCORE_INDEXED(pawnShieldBonus, shieldDistance - 1);
        }

        /* pawn storm -> advancing connected pawns together to apply pressure */
        if (s_passedPawnMaskTable[opponent][theirKingPos] & square) {
            const uint8_t shieldDistance = std::min(utils::verticalDistance(theirKingPos, pos), pawnStormSize);
            ADD_SCORE_INDEXED(pawnStormScore, shieldDistance - 1);
        }

        /* apply score if pawn is protected by one of our own pawns */
        if (square & ctx.pawnAttacks[player]) {
            ADD_SCORE_INDEXED(protectedPawnScore, row);
        }

        /* phalanx pawns -> two or more pawns adjacent */
        const uint64_t phalanxMask = utils::moveLeft(ourPawns) | utils::moveRight(ourPawns);
        if (square & phalanxMask) {
            ADD_SCORE(pawnPhalanxScore);
        }

        /* passed pawn terms
         * no stoppers -> passed pawn
         * stoppers    -> check if candidate to become passed pawn */
        const uint64_t stoppers = s_passedPawnMaskTable[player][pos] & theirPawns;
        if (stoppers == 0) {
            /* scores requiring full context will be added in "getPassedPawnsScore" */
            ctx.passedPawns[player] |= square;

            /* always apply bonus to passeds pawn */
            ADD_SCORE_INDEXED(passedPawnBonus, row);

            /* king pawn distance score -> apply score based on distance to our/their king */
            const uint8_t ourKingDistance = utils::absoluteDistance(pos, ourKingPos);
            const uint8_t theirKingDistance = utils::absoluteDistance(pos, theirKingPos);
            ADD_SCORE_INDEXED(passersOurKingDistance, ourKingDistance);
            ADD_SCORE_INDEXED(passersTheirKingDistance, theirKingDistance);
        } else {
            /* pawns that are not already considered passed pawns might be considered as candidates */
            const uint64_t pushedPos = utils::pushForwardFromPos<player>(pos);
            const uint64_t threats = movegen::getPawnAttacksFromPos<player>(pos) & theirPawns;
            const uint64_t defenders = movegen::getPawnAttacksFromPos<opponent>(pos) & ourPawns;
            const uint64_t pushedThreats = movegen::getPawnAttacks<player>(pushedPos) & theirPawns;
            const uint64_t pushedDefenders = movegen::getPawnAttacks<opponent>(pushedPos) & ourPawns;
            const uint64_t leftovers = stoppers ^ threats ^ pushedThreats;

            /* if no enemy pawns can safely stop the advance and the push square is not outnumbered,
             * consider the pawn a passer candidateâ€”classified by whether it's currently defended */
            if (!leftovers && std::popcount(pushedDefenders) >= std::popcount(pushedThreats)) {
                const bool defended = std::popcount(defenders) >= std::popcount(threats);
                if (defended) {
                    ADD_SCORE_INDEXED(passerCandidateDefended, row);
                } else {
                    ADD_SCORE_INDEXED(passerCandidateUndefended, row);
                }
            }
        }
    });

    return score;
}

template<Player player>
static inline TermScore getKnightScore(const BitBoard& board, TermContext& ctx, uint8_t& phaseScore)
{
    TermScore score(0, 0);

    constexpr Piece ourKnight = player == PlayerWhite ? WhiteKnight : BlackKnight;
    constexpr Piece ourPawn = player == PlayerWhite ? WhitePawn : BlackPawn;
    constexpr Piece theirPawn = player == PlayerWhite ? BlackPawn : WhitePawn;

    const uint64_t knights = board.pieces[ourKnight];

    constexpr Player opponent = nextPlayer(player);
    const uint64_t theirPawnAttacks = ctx.pawnAttacks[opponent];

    const uint64_t ourPawns = board.pieces[ourPawn];
    const uint64_t theirPawns = board.pieces[theirPawn];
    const uint64_t pawnDefends = ctx.pawnAttacks[player];

    /* apply bonus when sheltered behind one of our pawns */
    const uint64_t pawnShelters = utils::pushForward<player>(knights) & ourPawns;
    ADD_SCORE_MULTI(knightShelterBonus, std::popcount(pawnShelters));

    utils::bitIterate(knights, [&](BoardPosition pos) {
        const uint64_t moves = movegen::getKnightMoves(pos) & ~board.occupation[player];
        const uint64_t square = utils::positionToSquare(pos);

        phaseScore += s_piecePhaseValues[Knight];
        ADD_SCORE_INDEXED(pieceValues, Knight);
        ADD_SCORE_INDEXED(psqtKnights, utils::relativePosition<player>(pos));

        /* update mobility score based on possible moves that are not attacked by their pawns */
        const int mobilityCount = std::popcount(moves & ~theirPawnAttacks);
        ADD_SCORE_INDEXED(knightMobilityScore, mobilityCount);

        /* moves into opponent king zone -> update potential king attacks */
        ctx.attacksToKingZone[opponent] += std::popcount(moves & ctx.kingZone[opponent]);
        ctx.pieceAttacks[player][Knight] = moves;
        ctx.threats[player] |= moves;

        if (!(s_outpostSquareMaskTable[player][pos] & theirPawns) && square & s_outpostRankMaks[player]) {
            const bool isOutside = square & (s_aFileMask | s_hFileMask);
            const bool isDefended = square & pawnDefends;

            ADD_SCORE_INDEXED(knightOutpostScore, isOutside + (isDefended << 1));
        }
    });

    return score;
}

template<Player player>
static inline TermScore getBishopScore(const BitBoard& board, TermContext& ctx, uint8_t& phaseScore)
{
    TermScore score(0, 0);

    constexpr Piece ourBishops = player == PlayerWhite ? WhiteBishop : BlackBishop;
    constexpr Piece ourPawn = player == PlayerWhite ? WhitePawn : BlackPawn;
    constexpr Piece theirPawn = player == PlayerWhite ? BlackPawn : WhitePawn;

    const uint64_t bishops = board.pieces[ourBishops];

    constexpr Player opponent = nextPlayer(player);
    const uint64_t theirPawnAttacks = ctx.pawnAttacks[opponent];

    const uint64_t ourPawns = board.pieces[ourPawn];
    const uint64_t theirPawns = board.pieces[theirPawn];
    const uint64_t pawnDefends = ctx.pawnAttacks[player];

    /* apply bonus when sheltered behind one of our pawns */
    const uint64_t pawnShelters = utils::pushForward<player>(bishops) & ourPawns;
    ADD_SCORE_MULTI(bishopShelterBonus, std::popcount(pawnShelters));

    const int amntBishops = std::popcount(bishops);
    if (amntBishops >= 2)
        ADD_SCORE(bishopPairScore)

    utils::bitIterate(bishops, [&](BoardPosition pos) {
        const uint64_t moves = movegen::getBishopMoves(pos, board.occupation[Both]) & ~board.occupation[player];
        const uint64_t square = utils::positionToSquare(pos);

        phaseScore += s_piecePhaseValues[Bishop];
        ADD_SCORE_INDEXED(pieceValues, Bishop);
        ADD_SCORE_INDEXED(psqtBishops, utils::relativePosition<player>(pos));

        /* update mobility score based on possible moves that are not attacked by their pawns */
        const int mobilityCount = std::popcount(moves & ~theirPawnAttacks);
        ADD_SCORE_INDEXED(bishopMobilityScore, mobilityCount);

        const uint64_t coloredSquares = square & s_lightSquares ? s_lightSquares : s_darkSquares;
        const uint8_t blockingPawnsCount = std::popcount(coloredSquares & ourPawns);
        ADD_SCORE_INDEXED(badBishopScore, blockingPawnsCount);

        /* attaking two center squares means that the bishop controls the long diagonal (a1-h8 or h1-a8) */
        if (std::popcount(moves & s_centerSquares) >= 2) {
            ADD_SCORE(bishopLongDiagScore);
        }

        /* moves into opponent king zone -> update potential king attacks */
        ctx.attacksToKingZone[opponent] += std::popcount(moves & ctx.kingZone[opponent]);
        ctx.pieceAttacks[player][Bishop] = moves;
        ctx.threats[player] |= moves;

        if (!(s_outpostSquareMaskTable[player][pos] & theirPawns) && square & s_outpostRankMaks[player]) {
            const bool isOutside = square & (s_aFileMask | s_hFileMask);
            const bool isDefended = square & pawnDefends;

            ADD_SCORE_INDEXED(bishopOutpostScore, isOutside + (isDefended << 1));
        }
    });

    return score;
}

template<Player player>
static inline TermScore getRookScore(const BitBoard& board, TermContext& ctx, uint8_t& phaseScore)
{
    TermScore score(0, 0);

    constexpr Piece ourRooks = player == PlayerWhite ? WhiteRook : BlackRook;
    constexpr Piece ourPawn = player == PlayerWhite ? WhitePawn : BlackPawn;
    constexpr Piece theirPawn = player == PlayerWhite ? BlackPawn : WhitePawn;
    constexpr Piece theirKing = player == PlayerWhite ? BlackKing : WhiteKing;
    constexpr uint64_t row7Mask = player == PlayerWhite ? s_row7Mask : s_row2Mask;
    constexpr uint64_t row8Mask = player == PlayerWhite ? s_row8Mask : s_row1Mask;

    const uint64_t rooks = board.pieces[ourRooks];
    const uint64_t ourPawns = board.pieces[ourPawn];
    const uint64_t theirPawns = board.pieces[theirPawn];
    const uint64_t theirKings = board.pieces[theirKing];

    constexpr Player opponent = nextPlayer(player);
    const uint64_t theirPawnAttacks = ctx.pawnAttacks[opponent];

    utils::bitIterate(rooks, [&](BoardPosition pos) {
        const uint64_t moves = movegen::getRookMoves(pos, board.occupation[Both]) & ~board.occupation[player];

        phaseScore += s_piecePhaseValues[Rook];
        ADD_SCORE_INDEXED(pieceValues, Rook);
        ADD_SCORE_INDEXED(psqtRooks, utils::relativePosition<player>(pos));

        /* update mobility score based on possible moves that are not attacked by their pawns */
        const int mobilityCount = std::popcount(moves & ~theirPawnAttacks);
        ADD_SCORE_INDEXED(rookMobilityScore, mobilityCount);

        /* moves into opponent king zone -> update potential king attacks */
        ctx.attacksToKingZone[opponent] += std::popcount(moves & ctx.kingZone[opponent]);
        ctx.pieceAttacks[player][Rook] = moves;
        ctx.threats[player] |= moves;

        if (((ourPawns | theirPawns) & s_fileMaskTable[pos]) == 0)
            ADD_SCORE(rookOpenFileBonus);

        if ((ourPawns & s_fileMaskTable[pos]) == 0)
            ADD_SCORE(rookSemiOpenFileBonus);

        if (rooks & row7Mask) {
            if ((theirPawns & row7Mask) || (theirKings & row8Mask)) {
                ADD_SCORE(rook7thRankBonus);
            }
        }
    });

    return score;
}

template<Player player>
static inline TermScore getQueenScore(const BitBoard& board, TermContext& ctx, uint8_t& phaseScore)
{
    TermScore score(0, 0);

    constexpr Piece ourQueens = player == PlayerWhite ? WhiteQueen : BlackQueen;
    constexpr Piece ourPawn = player == PlayerWhite ? WhitePawn : BlackPawn;
    constexpr Piece theirPawn = player == PlayerWhite ? BlackPawn : WhitePawn;

    const uint64_t queens = board.pieces[ourQueens];
    const uint64_t ourPawns = board.pieces[ourPawn];
    const uint64_t theirPawns = board.pieces[theirPawn];

    constexpr Player opponent = nextPlayer(player);
    const uint64_t theirPawnAttacks = ctx.pawnAttacks[opponent];

    utils::bitIterate(queens, [&](BoardPosition pos) {
        const uint64_t moves
            = (movegen::getBishopMoves(pos, board.occupation[Both]) | movegen::getRookMoves(pos, board.occupation[Both]))
            & ~board.occupation[player];

        phaseScore += s_piecePhaseValues[Queen];
        ADD_SCORE_INDEXED(pieceValues, Queen);
        ADD_SCORE_INDEXED(psqtQueens, utils::relativePosition<player>(pos));

        if (((ourPawns | theirPawns) & s_fileMaskTable[pos]) == 0)
            ADD_SCORE(queenOpenFileBonus);

        if ((ourPawns & s_fileMaskTable[pos]) == 0)
            ADD_SCORE(queenSemiOpenFileBonus);

        /* update mobility score based on possible moves that are not attacked by their pawns */
        const int mobilityCount = std::popcount(moves & ~theirPawnAttacks);
        ADD_SCORE_INDEXED(queenMobilityScore, mobilityCount);

        /* moves into opponent king zone -> update potential king attacks */
        ctx.attacksToKingZone[opponent] += std::popcount(moves & ctx.kingZone[opponent]);
        ctx.pieceAttacks[player][Queen] = moves;
        ctx.threats[player] |= moves;
    });

    return score;
}

template<Player player>
static inline TermScore getKingScore(const BitBoard& board, TermContext& ctx)
{
    TermScore score(0, 0);

    constexpr Piece ourKing = player == PlayerWhite ? WhiteKing : BlackKing;
    const uint64_t king = board.pieces[ourKing];

    utils::bitIterate(king, [&](BoardPosition pos) {
        const uint64_t moves = movegen::getKingMoves(pos) & ~board.occupation[player];

        ctx.threats[player] |= moves;

        /* virtual mobility - replace king with queen to see potential attacks for sliding pieces */
        const uint64_t virtualMoves
            = (movegen::getBishopMoves(pos, board.occupation[Both]) | movegen::getRookMoves(pos, board.occupation[Both]))
            & ~board.occupation[player];
        const int virtualMovesCount = std::popcount(virtualMoves);
        ADD_SCORE_INDEXED(kingVirtualMobilityScore, virtualMovesCount);
    });

    return score;
}

template<Player player>
static inline TermScore getKingZoneScore(TermContext& ctx)
{
    TermScore score(0, 0);

    /* apply score / penalty based on the amount of attacks towards the king zone
     * the king zone is the 9 squares around the king ie. all king's attack for a given square
     * the work has been done while iterating each piece, so here we can simply
     * collect the counts and apply a score */
    const uint8_t kingZoneCount = std::min<uint8_t>(ctx.attacksToKingZone[player], kingZoneSize - 1);
    ADD_SCORE_INDEXED(kingZone, kingZoneCount);

    return score;
}

template<Player player>
static inline TermScore getPieceAttacksScore(const BitBoard& board, TermContext& ctx)
{
    TermScore score(0, 0);

    constexpr Player opponent = nextPlayer(player);
    constexpr auto opponentPieces = player == PlayerWhite
        ? std::to_array<Piece>({ BlackPawn, BlackKnight, BlackBishop, BlackRook, BlackQueen })
        : std::to_array<Piece>({ WhitePawn, WhiteKnight, WhiteBishop, WhiteRook, WhiteQueen });

    /* apply score/penalty based on which of our pieces are attacking our opponent's pieces
     * the score is multiplied by the amount of attacks from given pieces towards each piece */
    for (const auto piece : opponentPieces) {
        const int pawnCount = std::popcount(board.pieces[piece] & ctx.pieceAttacks[player][Pawn]);
        const int knightCount = std::popcount(board.pieces[piece] & ctx.pieceAttacks[player][Knight]);
        const int bishopCount = std::popcount(board.pieces[piece] & ctx.pieceAttacks[player][Bishop]);
        const int rookCount = std::popcount(board.pieces[piece] & ctx.pieceAttacks[player][Rook]);
        const int queenCount = std::popcount(board.pieces[piece] & ctx.pieceAttacks[player][Queen]);

        const auto colorlessPiece = pieceToColorlessPiece<opponent>(piece);
        ADD_SCORE_MULTI_INDEXED(pawnAttacks, pawnCount, colorlessPiece);
        ADD_SCORE_MULTI_INDEXED(knightAttacks, knightCount, colorlessPiece);
        ADD_SCORE_MULTI_INDEXED(bishopAttacks, bishopCount, colorlessPiece);
        ADD_SCORE_MULTI_INDEXED(rookAttacks, rookCount, colorlessPiece);
        ADD_SCORE_MULTI_INDEXED(queenAttacks, queenCount, colorlessPiece);
    }

    return score;
}

template<Player player>
static inline TermScore getChecksScore(const BitBoard& board, TermContext& ctx)
{
    TermScore score(0, 0);

    constexpr Player opponent = nextPlayer(player);
    constexpr Piece theirKing = player == PlayerWhite ? BlackKing : WhiteKing;
    constexpr Piece ourPawns = player == PlayerWhite ? WhitePawn : BlackPawn;

    const uint64_t occupation = board.occupation[Both];
    const uint64_t unsafeMask = ctx.threats[opponent];
    const uint64_t safeMask = ~unsafeMask;

    /* pawns are little more complicated - attack mask doesn't include pushed pawns */
    const uint64_t ourPawnsPushed = utils::pushForward<player>(board.pieces[ourPawns]);

    /* fetch king's position and compute each piece attack from there */
    const BoardPosition theirKingPos = utils::lsbToPosition(board.pieces[theirKing]);
    const uint64_t kingPawnMoves = movegen::getPawnAttacksFromPos<opponent>(theirKingPos);
    const uint64_t kingKnightMoves = movegen::getKnightMoves(theirKingPos);
    const uint64_t kingBishopMoves = movegen::getBishopMoves(theirKingPos, occupation);
    const uint64_t kingRookMoves = movegen::getRookMoves(theirKingPos, occupation);
    const uint64_t kingQueenMoves = kingBishopMoves | kingRookMoves;

    /* calculate how many moves each piece has that can cause a check */
    const uint64_t pawnChecks = (ctx.pieceAttacks[player][Pawn] | ourPawnsPushed) & kingPawnMoves;
    const uint64_t knightChecks = ctx.pieceAttacks[player][Knight] & kingKnightMoves;
    const uint64_t bishopChecks = ctx.pieceAttacks[player][Bishop] & kingBishopMoves;
    const uint64_t rookChecks = ctx.pieceAttacks[player][Rook] & kingRookMoves;
    const uint64_t queenChecks = ctx.pieceAttacks[player][Queen] & kingQueenMoves;

    /* safe checks   -> moves that can cause a check without putting ourselves in danger (piece is not attacked while checking)
     * unsafe checks -> moves that can cause a check but will put ourselves in danger (piece is attacked while checking) */

    /* apply score for safe checks */
    ADD_SCORE_MULTI_INDEXED(safeChecks, std::popcount(pawnChecks & safeMask), Pawn);
    ADD_SCORE_MULTI_INDEXED(safeChecks, std::popcount(knightChecks & safeMask), Knight);
    ADD_SCORE_MULTI_INDEXED(safeChecks, std::popcount(bishopChecks & safeMask), Bishop);
    ADD_SCORE_MULTI_INDEXED(safeChecks, std::popcount(rookChecks & safeMask), Rook);
    ADD_SCORE_MULTI_INDEXED(safeChecks, std::popcount(queenChecks & safeMask), Queen);

    /* apply score for unsafe checks */
    ADD_SCORE_MULTI_INDEXED(unsafeChecks, std::popcount(pawnChecks & unsafeMask), Pawn);
    ADD_SCORE_MULTI_INDEXED(unsafeChecks, std::popcount(knightChecks & unsafeMask), Knight);
    ADD_SCORE_MULTI_INDEXED(unsafeChecks, std::popcount(bishopChecks & unsafeMask), Bishop);
    ADD_SCORE_MULTI_INDEXED(unsafeChecks, std::popcount(rookChecks & unsafeMask), Rook);
    ADD_SCORE_MULTI_INDEXED(unsafeChecks, std::popcount(queenChecks & unsafeMask), Queen);

    return score;
}

template<Player player>
static inline TermScore getPawnPushThreatScore(const BitBoard& board, TermContext& ctx)
{
    TermScore score(0, 0);

    constexpr Player opponent = nextPlayer(player);
    constexpr Piece ourPawns = player == PlayerWhite ? WhitePawn : BlackPawn;
    constexpr Piece theirPawns = player == PlayerWhite ? BlackPawn : WhitePawn;
    constexpr uint64_t thirdRow = player == PlayerWhite ? s_row3Mask : s_row6Mask;

    /* all opponent's pieces with pawns excluded */
    const uint64_t targets = board.occupation[opponent] & ~board.pieces[theirPawns];

    /* squares are safe if not attacked by our opponent or if defended while it's not an opponent pawn attacking */
    const uint64_t safeMask = ~ctx.threats[opponent] | (~ctx.pieceAttacks[opponent][Pawn] & ctx.threats[player]);

    /* compute legal pushes */
    const uint64_t pushes = utils::pushForward<player>(board.pieces[ourPawns]) & ~board.occupation[Both];
    const uint64_t doublePushes = utils::pushForward<player>(pushes & thirdRow) & ~board.occupation[Both];
    const uint64_t safePushes = (pushes | doublePushes) & safeMask;

    /* compute potential attacks from our safed pushed positions */
    const uint64_t attacks = movegen::getPawnAttacks<player>(safePushes) & targets;

    /* iterate each attack and assign a bonus based on what type of piece we're attacking if pushed
     * ie pawn push threats -> pawns that can be pushed and cause a "safe" attack towards a non-pawn piece */
    utils::bitIterate(attacks, [&](BoardPosition pos) {
        const uint64_t square = utils::positionToSquare(pos);
        const auto target = board.getTargetAtSquare<player>(square);
        const auto colorlessPiece = pieceToColorlessPiece<opponent>(*target);
        ADD_SCORE_INDEXED(pawnPushThreats, colorlessPiece);
    });

    return score;
}

template<Player player>
static inline TermScore getPassedPawnsScore(const BitBoard& board, TermContext& ctx)
{
    TermScore score(0, 0);

    constexpr Player opponent = nextPlayer(player);
    constexpr Piece theirPawns = player == PlayerWhite ? BlackPawn : WhitePawn;
    constexpr Piece theirKing = player == PlayerWhite ? BlackKing : WhiteKing;

    const uint64_t passedPawns = ctx.passedPawns[player];
    const auto theirKingPos = utils::lsbToPosition(board.pieces[theirKing]);
    const bool kingPawnsOnly = board.occupation[opponent] == (board.pieces[theirKing] | board.pieces[theirPawns]);
    const bool tempo = board.player == opponent;

    utils::bitIterate(passedPawns, [&](BoardPosition pos) {
        const uint8_t row = utils::relativeRow<player>(pos);
        const uint64_t pushedSquare = utils::pushForwardFromPos<player>(pos);

        /* if we can push the pawn without it being attacked -> apply free push bonus */
        const bool freePush = (board.occupation[Both] & pushedSquare) == 0 && (ctx.threats[opponent] & pushedSquare) == 0;
        if (freePush) {
            ADD_SCORE_INDEXED(freePassedPawnBonus, row);
        }

        /* if we can push the pawn into being defended -> apply protected pawn bonus */
        const bool protectedPush = (ctx.threats[player] & pushedSquare) != 0;
        if (protectedPush) {
            ADD_SCORE_INDEXED(protectedPassedPawnBonus, row);
        }

        /* pawn square rule https://www.chess.com/terms/square-rule-chess */
        const uint8_t promotionDistance = 7 - row;
        const uint8_t distanceToTheirKing = utils::absoluteDistance(pos, theirKingPos);
        const bool pawnSquareRule = kingPawnsOnly
            && promotionDistance <= 4 /* only apply square rule when relevant */
            && promotionDistance < (distanceToTheirKing - static_cast<uint8_t>(tempo));

        if (pawnSquareRule) {
            ADD_SCORE(pawnSquareRuleBonus);
        }
    });

    return score;
}

}
