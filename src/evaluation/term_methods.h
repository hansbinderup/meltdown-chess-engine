#pragma once

#include "core/bit_board.h"
#include "evaluation/generated/tuned_terms.h"
#include "evaluation/position_tables.h"
#include "movegen/bishops.h"
#include "movegen/knights.h"
#include "movegen/rooks.h"
#include "utils/bit_operations.h"

#include <array>

#ifdef TUNING

#include "tuner/term_tracer.h"

#define ADD_SCORE_INDEXED(weightName, index) \
    {                                        \
        score += s_terms.weightName[index];  \
        if constexpr (player == PlayerWhite) \
            s_trace.weightName[index]++;     \
        else                                 \
            s_trace.weightName[index]--;     \
    }

#define ADD_SCORE_MULTI_INDEXED(weightName, multi, index) \
    {                                                     \
        score += s_terms.weightName[index] * multi;       \
        if constexpr (player == PlayerWhite)              \
            s_trace.weightName[index] += multi;           \
        else                                              \
            s_trace.weightName[index] -= multi;           \
    }

#else

#define ADD_SCORE_INDEXED(weightName, index) \
    {                                        \
        score += s_terms.weightName[index];  \
    }

#define ADD_SCORE_MULTI_INDEXED(weightName, multi, index) \
    {                                                     \
        score += s_terms.weightName[index] * multi;       \
    }

#endif

/* helper for single index tables */
#define ADD_SCORE(weightName) ADD_SCORE_INDEXED(weightName, 0)
#define ADD_SCORE_MULTI(weightName, multi) ADD_SCORE_MULTI_INDEXED(weightName, multi, 0)

namespace evaluation {

/* A context to precompute heavy operations so we don't have to do that
 * multiple times for a single evaluation
 * NOTE: Only values that are being reused between terms should be added here */
struct TermContext {
    const std::array<uint64_t, magic_enum::enum_count<Player>()> pawnAttacks;
    const std::array<uint64_t, magic_enum::enum_count<Player>()> kingZone;

    std::array<uint8_t, magic_enum::enum_count<Player>()> attacksToKingZone;

    /* attacks generated by each piece will be populated here */
    using AttackArray = std::array<uint64_t, magic_enum::enum_count<ColorlessPiece>()>;
    std::array<AttackArray, magic_enum::enum_count<Player>()> pieceAttacks;
};

[[nodiscard]] constexpr uint64_t flipPosition(BoardPosition pos) noexcept
{
    return pos ^ 56;
}

template<Player player>
[[nodiscard]] constexpr inline ColorlessPiece pieceToColorlessPiece(Piece piece) noexcept
{
    if constexpr (player == PlayerWhite) {
        assert(piece < BlackPawn);
        return static_cast<ColorlessPiece>(piece);
    } else {
        assert(piece >= BlackPawn);
        return static_cast<ColorlessPiece>(piece - BlackPawn);
    }
}

constexpr uint8_t pawnShieldSize = s_terms.pawnShieldBonus.size();
constexpr uint8_t kingZoneSize = s_terms.kingZone.size();

template<Player player>
static inline TermScore getPawnScore(const BitBoard& board, TermContext& ctx)
{
    TermScore score(0, 0);

    constexpr Piece ourPawns = player == PlayerWhite ? WhitePawn : BlackPawn;
    const uint64_t pawns = board.pieces[ourPawns];

    constexpr Piece ourKing = player == PlayerWhite ? WhiteKing : BlackKing;
    constexpr Player opponent = nextPlayer(player);

    /* we have already generated all pawn attacks, so we can simply update ctx as single operations */
    ctx.attacksToKingZone[opponent] += std::popcount(ctx.kingZone[opponent] & ctx.pawnAttacks[player]);
    ctx.pieceAttacks[player][Pawn] = ctx.pawnAttacks[player];

    utils::bitIterate(pawns, [&](BoardPosition pos) {
        const uint64_t square = utils::positionToSquare(pos);

        ADD_SCORE_INDEXED(pieceValues, Pawn);

        const auto doubledPawns = std::popcount(pawns & s_fileMaskTable[pos]);
        if (doubledPawns > 1)
            ADD_SCORE(doublePawnPenalty);

        if ((pawns & s_isolationMaskTable[pos]) == 0)
            ADD_SCORE(isolatedPawnPenalty);

        const auto kingPos = utils::lsbToPosition(board.pieces[ourKing]);
        if (s_passedPawnMaskTable[player][kingPos] & square) {
            const uint8_t shieldDistance = std::min(utils::verticalDistance(kingPos, pos), pawnShieldSize);
            ADD_SCORE_INDEXED(pawnShieldBonus, shieldDistance - 1);
        }

        if constexpr (player == PlayerWhite) {
            ADD_SCORE_INDEXED(psqtPawns, pos);

            if ((board.pieces[BlackPawn] & s_passedPawnMaskTable[player][pos]) == 0) {
                const uint8_t row = (pos / 8);
                ADD_SCORE_INDEXED(passedPawnBonus, row);
            }

        } else {
            ADD_SCORE_INDEXED(psqtPawns, flipPosition(pos));

            if ((board.pieces[WhitePawn] & s_passedPawnMaskTable[player][pos]) == 0) {
                const uint8_t row = 7 - (pos / 8);
                ADD_SCORE_INDEXED(passedPawnBonus, row);
            }
        }
    });

    return score;
}

template<Player player>
static inline TermScore getKnightScore(const BitBoard& board, TermContext& ctx, uint8_t& phaseScore)
{
    TermScore score(0, 0);

    constexpr Piece ourKnights = player == PlayerWhite ? WhiteKnight : BlackKnight;
    const uint64_t knights = board.pieces[ourKnights];

    constexpr Player opponent = nextPlayer(player);
    const uint64_t theirPawnAttacks = ctx.pawnAttacks[opponent];

    const uint64_t whitePawns = board.pieces[WhitePawn];
    const uint64_t blackPawns = board.pieces[BlackPawn];
    const uint64_t pawnDefends = ctx.pawnAttacks[player];

    utils::bitIterate(knights, [&](BoardPosition pos) {
        const uint64_t moves = movegen::getKnightMoves(pos) & ~board.occupation[player];
        const uint64_t square = utils::positionToSquare(pos);

        phaseScore += s_piecePhaseValues[Knight];
        ADD_SCORE_INDEXED(pieceValues, Knight);

        /* update mobility score based on possible moves that are not attacked by their pawns */
        const int mobilityCount = std::popcount(moves & ~theirPawnAttacks);
        ADD_SCORE_INDEXED(knightMobilityScore, mobilityCount);

        /* moves into opponent king zone -> update potential king attacks */
        ctx.attacksToKingZone[opponent] += std::popcount(moves & ctx.kingZone[opponent]);
        ctx.pieceAttacks[player][Knight] = moves;

        if constexpr (player == PlayerWhite) {
            ADD_SCORE_INDEXED(psqtKnights, pos);

            if (!(s_outpostSquareMaskTable[player][pos] & blackPawns) && square & s_whiteOutpostRankMask) {
                const bool isOutside = square & (s_aFileMask | s_hFileMask);
                const bool isDefended = square & pawnDefends;

                ADD_SCORE_INDEXED(knightOutpostScore, isOutside + (isDefended << 1));
            }

        } else {
            ADD_SCORE_INDEXED(psqtKnights, flipPosition(pos));

            if (!(s_outpostSquareMaskTable[player][pos] & whitePawns) && square & s_blackOutpostRankMask) {
                const bool isOutside = square & (s_aFileMask | s_hFileMask);
                const bool isDefended = square & pawnDefends;

                ADD_SCORE_INDEXED(knightOutpostScore, isOutside + (isDefended << 1));
            }
        }
    });

    return score;
}

template<Player player>
static inline TermScore getBishopScore(const BitBoard& board, TermContext& ctx, uint8_t& phaseScore)
{
    TermScore score(0, 0);

    constexpr Piece ourBishops = player == PlayerWhite ? WhiteBishop : BlackBishop;
    const uint64_t bishops = board.pieces[ourBishops];

    constexpr Player opponent = nextPlayer(player);
    const uint64_t theirPawnAttacks = ctx.pawnAttacks[opponent];

    const uint64_t whitePawns = board.pieces[WhitePawn];
    const uint64_t blackPawns = board.pieces[BlackPawn];
    const uint64_t pawnDefends = ctx.pawnAttacks[player];

    const int amntBishops = std::popcount(bishops);
    if (amntBishops >= 2)
        ADD_SCORE(bishopPairScore)

    utils::bitIterate(bishops, [&](BoardPosition pos) {
        const uint64_t moves = movegen::getBishopMoves(pos, board.occupation[Both]) & ~board.occupation[player];
        const uint64_t square = utils::positionToSquare(pos);

        phaseScore += s_piecePhaseValues[Bishop];
        ADD_SCORE_INDEXED(pieceValues, Bishop);

        /* update mobility score based on possible moves that are not attacked by their pawns */
        const int mobilityCount = std::popcount(moves & ~theirPawnAttacks);
        ADD_SCORE_INDEXED(bishopMobilityScore, mobilityCount);

        /* moves into opponent king zone -> update potential king attacks */
        ctx.attacksToKingZone[opponent] += std::popcount(moves & ctx.kingZone[opponent]);
        ctx.pieceAttacks[player][Bishop] = moves;

        if constexpr (player == PlayerWhite) {
            ADD_SCORE_INDEXED(psqtBishops, pos);

            if (!(s_outpostSquareMaskTable[player][pos] & blackPawns) && square & s_whiteOutpostRankMask) {
                const bool isOutside = square & (s_aFileMask | s_hFileMask);
                const bool isDefended = square & pawnDefends;

                ADD_SCORE_INDEXED(bishopOutpostScore, isOutside + (isDefended << 1));
            }
        } else {
            ADD_SCORE_INDEXED(psqtBishops, flipPosition(pos));

            if (!(s_outpostSquareMaskTable[player][pos] & whitePawns) && square & s_blackOutpostRankMask) {
                const bool isOutside = square & (s_aFileMask | s_hFileMask);
                const bool isDefended = square & pawnDefends;

                ADD_SCORE_INDEXED(bishopOutpostScore, isOutside + (isDefended << 1));
            }
        }
    });

    return score;
}

template<Player player>
static inline TermScore getRookScore(const BitBoard& board, TermContext& ctx, uint8_t& phaseScore)
{
    TermScore score(0, 0);

    constexpr Piece ourRooks = player == PlayerWhite ? WhiteRook : BlackRook;
    const uint64_t rooks = board.pieces[ourRooks];

    constexpr Player opponent = nextPlayer(player);
    const uint64_t theirPawnAttacks = ctx.pawnAttacks[opponent];

    const uint64_t whitePawns = board.pieces[WhitePawn];
    const uint64_t blackPawns = board.pieces[BlackPawn];

    const uint64_t whiteKing = board.pieces[WhiteKing];
    const uint64_t blackKing = board.pieces[BlackKing];

    utils::bitIterate(rooks, [&](BoardPosition pos) {
        const uint64_t moves = movegen::getRookMoves(pos, board.occupation[Both]) & ~board.occupation[player];

        phaseScore += s_piecePhaseValues[Rook];
        ADD_SCORE_INDEXED(pieceValues, Rook);

        /* update mobility score based on possible moves that are not attacked by their pawns */
        const int mobilityCount = std::popcount(moves & ~theirPawnAttacks);
        ADD_SCORE_INDEXED(rookMobilityScore, mobilityCount);

        /* moves into opponent king zone -> update potential king attacks */
        ctx.attacksToKingZone[opponent] += std::popcount(moves & ctx.kingZone[opponent]);
        ctx.pieceAttacks[player][Rook] = moves;

        if (((whitePawns | blackPawns) & s_fileMaskTable[pos]) == 0)
            ADD_SCORE(rookOpenFileBonus);

        if constexpr (player == PlayerWhite) {
            ADD_SCORE_INDEXED(psqtRooks, pos);
            if ((whitePawns & s_fileMaskTable[pos]) == 0)
                ADD_SCORE(rookSemiOpenFileBonus);

            if (rooks & s_row7Mask) {
                if ((blackPawns & s_row7Mask) || (blackKing & s_row8Mask)) {
                    ADD_SCORE(rook7thRankBonus);
                }
            }

        } else {
            ADD_SCORE_INDEXED(psqtRooks, flipPosition(pos));
            if ((blackPawns & s_fileMaskTable[pos]) == 0)
                ADD_SCORE(rookSemiOpenFileBonus);

            if (rooks & s_row2Mask) {
                if ((whitePawns & s_row2Mask) || (whiteKing & s_row1Mask)) {
                    ADD_SCORE(rook7thRankBonus);
                }
            }
        }
    });

    return score;
}

template<Player player>
static inline TermScore getQueenScore(const BitBoard& board, TermContext& ctx, uint8_t& phaseScore)
{
    TermScore score(0, 0);

    constexpr Piece ourQueens = player == PlayerWhite ? WhiteQueen : BlackQueen;
    const uint64_t queens = board.pieces[ourQueens];

    constexpr Player opponent = nextPlayer(player);
    const uint64_t theirPawnAttacks = ctx.pawnAttacks[opponent];

    const uint64_t whitePawns = board.pieces[WhitePawn];
    const uint64_t blackPawns = board.pieces[BlackPawn];

    utils::bitIterate(queens, [&](BoardPosition pos) {
        const uint64_t moves
            = (movegen::getBishopMoves(pos, board.occupation[Both]) | movegen::getRookMoves(pos, board.occupation[Both]))
            & ~board.occupation[player];

        phaseScore += s_piecePhaseValues[Queen];
        ADD_SCORE_INDEXED(pieceValues, Queen);

        if (((whitePawns | blackPawns) & s_fileMaskTable[pos]) == 0)
            ADD_SCORE(queenOpenFileBonus);

        /* update mobility score based on possible moves that are not attacked by their pawns */
        const int mobilityCount = std::popcount(moves & ~theirPawnAttacks);
        ADD_SCORE_INDEXED(queenMobilityScore, mobilityCount);

        /* moves into opponent king zone -> update potential king attacks */
        ctx.attacksToKingZone[opponent] += std::popcount(moves & ctx.kingZone[opponent]);
        ctx.pieceAttacks[player][Queen] = moves;

        if constexpr (player == PlayerWhite) {
            ADD_SCORE_INDEXED(psqtQueens, pos);
            if ((whitePawns & s_fileMaskTable[pos]) == 0)
                ADD_SCORE(queenSemiOpenFileBonus);
        } else {
            ADD_SCORE_INDEXED(psqtQueens, flipPosition(pos));
            if ((blackPawns & s_fileMaskTable[pos]) == 0)
                ADD_SCORE(queenSemiOpenFileBonus);
        }
    });

    return score;
}

template<Player player>
static inline TermScore getKingScore(const BitBoard& board)
{
    TermScore score(0, 0);

    constexpr Piece ourKing = player == PlayerWhite ? WhiteKing : BlackKing;
    const uint64_t king = board.pieces[ourKing];

    utils::bitIterate(king, [&](BoardPosition pos) {
        /* virtual mobility - replace king with queen to see potential attacks for sliding pieces */
        const uint64_t virtualMoves
            = (movegen::getBishopMoves(pos, board.occupation[Both]) | movegen::getRookMoves(pos, board.occupation[Both]))
            & ~board.occupation[player];
        const int virtualMovesCount = std::popcount(virtualMoves);
        ADD_SCORE_INDEXED(kingVirtualMobilityScore, virtualMovesCount);

        if constexpr (player == PlayerWhite) {
            ADD_SCORE_INDEXED(psqtKings, pos);
        } else {
            ADD_SCORE_INDEXED(psqtKings, flipPosition(pos));
        }
    });

    return score;
}

template<Player player>
static inline TermScore getKingZoneScore(TermContext& ctx)
{
    TermScore score(0, 0);

    /* apply score / penalty based on the amount of attacks towards the king zone
     * the king zone is the 9 squares around the king ie. all king's attack for a given square
     * the work has been done while iterating each piece, so here we can simply
     * collect the counts and apply a score */
    const uint8_t kingZoneCount = std::min<uint8_t>(ctx.attacksToKingZone[player], kingZoneSize - 1);
    ADD_SCORE_INDEXED(kingZone, kingZoneCount);

    return score;
}

template<Player player>
static inline TermScore getPieceAttacksScore(const BitBoard& board, TermContext& ctx)
{
    TermScore score(0, 0);

    constexpr Player opponent = nextPlayer(player);
    constexpr auto opponentPieces = player == PlayerWhite
        ? std::to_array<Piece>({ BlackPawn, BlackKnight, BlackBishop, BlackRook, BlackQueen })
        : std::to_array<Piece>({ WhitePawn, WhiteKnight, WhiteBishop, WhiteRook, WhiteQueen });

    /* apply score/penalty based on which of our pieces are attacking our opponent's pieces
     * the score is multiplied by the amount of attacks from given pieces towards each piece */
    for (const auto piece : opponentPieces) {
        const int pawnCount = std::popcount(board.pieces[piece] & ctx.pieceAttacks[player][Pawn]);
        const int knightCount = std::popcount(board.pieces[piece] & ctx.pieceAttacks[player][Knight]);
        const int bishopCount = std::popcount(board.pieces[piece] & ctx.pieceAttacks[player][Bishop]);
        const int rookCount = std::popcount(board.pieces[piece] & ctx.pieceAttacks[player][Rook]);
        const int queenCount = std::popcount(board.pieces[piece] & ctx.pieceAttacks[player][Queen]);

        const auto colorlessPiece = pieceToColorlessPiece<opponent>(piece);
        ADD_SCORE_MULTI_INDEXED(pawnAttacks, pawnCount, colorlessPiece);
        ADD_SCORE_MULTI_INDEXED(knightAttacks, knightCount, colorlessPiece);
        ADD_SCORE_MULTI_INDEXED(bishopAttacks, bishopCount, colorlessPiece);
        ADD_SCORE_MULTI_INDEXED(rookAttacks, rookCount, colorlessPiece);
        ADD_SCORE_MULTI_INDEXED(queenAttacks, queenCount, colorlessPiece);
    }

    return score;
}

}
